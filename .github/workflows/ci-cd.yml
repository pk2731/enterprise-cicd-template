name: 🚀 CI/CD Pipeline

on:
  push:
    branches: [ main, develop, staging ]
  pull_request:
    branches: [ main, develop, staging ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
  SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

jobs:
  # ====================================
  # QUALITY GATES & TESTING
  # ====================================
  quality-gates:
    name: 🔍 Quality Gates
    runs-on: ubuntu-latest
    outputs:
      should-deploy: ${{ steps.quality-check.outputs.should-deploy }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Shallow clones should be disabled for better analysis

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    # LINTING
    - name: 🧹 ESLint Check
      run: |
        npm run lint
        echo "✅ Linting passed"

    # FORMATTING
    - name: 🎨 Prettier Check
      run: |
        npm run format:check
        echo "✅ Code formatting verified"

    # SECURITY SCAN
    - name: 🔒 Security Audit
      run: |
        npm audit --audit-level=moderate
        echo "✅ Security audit completed"

    # DEPENDENCY VULNERABILITY SCAN
    - name: 🛡️ Dependency Vulnerability Scan
      uses: actions/dependency-review-action@v4
      if: github.event_name == 'pull_request'

    # UNIT TESTS
    - name: 🧪 Unit Tests
      run: |
        npm run test:coverage
        echo "✅ Unit tests completed"

    # INTEGRATION TESTS
    - name: 🔗 Integration Tests
      run: |
        npm run test:integration
        echo "✅ Integration tests completed"

    # TEST COVERAGE REPORT
    - name: 📊 Upload Coverage to Codecov
      uses: codecov/codecov-action@v4
      with:
        file: ./coverage/lcov.info
        flags: unittests
        name: codecov-umbrella
        fail_ci_if_error: true

    # SONARQUBE ANALYSIS
    - name: 📈 SonarQube Scan
      uses: sonarqube-quality-gate-action@master
      with:
        scanMetadataReportFile: target/sonar/report-task.txt
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

    - name: 🔍 SonarQube Code Analysis
      uses: SonarSource/sonarqube-scan-action@master
      env:
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

    # PERFORMANCE TESTS
    - name: ⚡ Performance Tests
      run: |
        npm run test:performance
        echo "✅ Performance tests completed"

    # BUILD VERIFICATION
    - name: 🏗️ Build Verification
      run: |
        npm run build
        echo "✅ Build verification completed"

    # QUALITY GATE DECISION
    - name: ✅ Quality Gate Decision
      id: quality-check
      run: |
        echo "All quality gates passed successfully!"
        echo "should-deploy=true" >> $GITHUB_OUTPUT

  # ====================================
  # DOCKER IMAGE BUILD & PUSH
  # ====================================
  build-and-push:
    name: 🐳 Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: quality-gates
    if: needs.quality-gates.outputs.should-deploy == 'true'
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ steps.meta.outputs.tags }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # ====================================
  # DEVELOPMENT DEPLOYMENT
  # ====================================
  deploy-dev:
    name: 🚀 Deploy to Development
    runs-on: ubuntu-latest
    needs: [quality-gates, build-and-push]
    if: github.ref == 'refs/heads/develop' && needs.quality-gates.outputs.should-deploy == 'true'
    environment:
      name: development
      url: https://dev.yourapp.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Deploy to Development
      run: |
        echo "🚀 Deploying to Development Environment"
        chmod +x ./scripts/deploy-dev.sh
        ./scripts/deploy-dev.sh ${{ needs.build-and-push.outputs.image-tag }}
      env:
        DEV_SERVER_HOST: ${{ secrets.DEV_SERVER_HOST }}
        DEV_SERVER_USER: ${{ secrets.DEV_SERVER_USER }}
        DEV_SERVER_KEY: ${{ secrets.DEV_SERVER_KEY }}

    - name: Health Check - Development
      run: |
        echo "🏥 Running health checks..."
        chmod +x ./scripts/health-check.sh
        ./scripts/health-check.sh https://dev.yourapp.com

  # ====================================
  # STAGING DEPLOYMENT
  # ====================================
  deploy-staging:
    name: 🚀 Deploy to Staging
    runs-on: ubuntu-latest
    needs: [quality-gates, build-and-push]
    if: github.ref == 'refs/heads/staging' && needs.quality-gates.outputs.should-deploy == 'true'
    environment:
      name: staging
      url: https://staging.yourapp.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Deploy to Staging
      run: |
        echo "🚀 Deploying to Staging Environment"
        chmod +x ./scripts/deploy-staging.sh
        ./scripts/deploy-staging.sh ${{ needs.build-and-push.outputs.image-tag }}
      env:
        STAGING_SERVER_HOST: ${{ secrets.STAGING_SERVER_HOST }}
        STAGING_SERVER_USER: ${{ secrets.STAGING_SERVER_USER }}
        STAGING_SERVER_KEY: ${{ secrets.STAGING_SERVER_KEY }}

    - name: Health Check - Staging
      run: |
        echo "🏥 Running health checks..."
        chmod +x ./scripts/health-check.sh
        ./scripts/health-check.sh https://staging.yourapp.com

    - name: Run E2E Tests on Staging
      run: |
        echo "🧪 Running E2E tests on staging..."
        npm run test:e2e -- --base-url=https://staging.yourapp.com

  # ====================================
  # PRODUCTION DEPLOYMENT (KUBERNETES)
  # ====================================
  deploy-production:
    name: 🚀 Deploy to Production (Kubernetes)
    runs-on: ubuntu-latest
    needs: [quality-gates, build-and-push]
    if: github.ref == 'refs/heads/main' && needs.quality-gates.outputs.should-deploy == 'true'
    environment:
      name: production
      url: https://yourapp.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Configure kubectl for EKS
      run: |
        aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name ${{ secrets.EKS_CLUSTER_NAME }}
        echo "✅ kubectl configured for EKS cluster"

    - name: 🔒 Security Scan Docker Image
      run: |
        echo "🔍 Scanning Docker image for vulnerabilities..."
        # Add your container scanning tool here (e.g., Trivy, Snyk)
        echo "✅ Container security scan completed"

    - name: 🚀 Deploy to Kubernetes Production
      run: |
        echo "🚀 Deploying to Production Kubernetes Cluster"
        
        # Update image tag in deployment manifest
        sed -i "s|IMAGE_TAG_PLACEHOLDER|${{ needs.build-and-push.outputs.image-tag }}|g" k8s/production/deployment.yaml
        
        # Apply Kubernetes manifests
        kubectl apply -f k8s/production/namespace.yaml
        kubectl apply -f k8s/production/configmap.yaml
        kubectl apply -f k8s/production/secret.yaml
        kubectl apply -f k8s/production/deployment.yaml
        kubectl apply -f k8s/production/service.yaml
        kubectl apply -f k8s/production/ingress.yaml
        kubectl apply -f k8s/production/hpa.yaml
        
        echo "✅ Kubernetes deployment completed"

    - name: 🔄 Rolling Update Status
      run: |
        echo "🔄 Checking rolling update status..."
        kubectl rollout status deployment/app-deployment -n production --timeout=600s
        echo "✅ Rolling update completed successfully"

    - name: 🏥 Production Health Check
      run: |
        echo "🏥 Running production health checks..."
        sleep 30  # Wait for services to be ready
        chmod +x ./scripts/health-check.sh
        ./scripts/health-check.sh https://yourapp.com

    - name: 📊 Post-Deployment Verification
      run: |
        echo "📊 Running post-deployment verification..."
        
        # Check pod status
        kubectl get pods -n production -l app=yourapp
        
        # Check service endpoints
        kubectl get endpoints -n production
        
        # Check ingress status
        kubectl get ingress -n production
        
        echo "✅ Post-deployment verification completed"

    - name: 🚨 Rollback on Failure
      if: failure()
      run: |
        echo "🚨 Deployment failed - initiating rollback..."
        kubectl rollout undo deployment/app-deployment -n production
        kubectl rollout status deployment/app-deployment -n production
        echo "✅ Rollback completed"

  # ====================================
  # NOTIFICATIONS
  # ====================================
  notify:
    name: 📢 Notifications
    runs-on: ubuntu-latest
    needs: [deploy-dev, deploy-staging, deploy-production]
    if: always()
    
    steps:
    - name: Notify Teams on Success
      if: needs.deploy-production.result == 'success'
      run: |
        curl -X POST ${{ secrets.TEAMS_WEBHOOK_URL }} \
        -H 'Content-Type: application/json' \
        -d '{
          "text": "✅ Production Deployment Successful",
          "sections": [{
            "activityTitle": "Deployment Success",
            "activitySubtitle": "'"${{ github.repository }}"'",
            "facts": [
              {"name": "Environment", "value": "Production"},
              {"name": "Branch", "value": "'"${{ github.ref_name }}"'"},
              {"name": "Commit", "value": "'"${{ github.sha }}"'"},
              {"name": "Deployed by", "value": "Automated Pipeline"}
            ]
          }]
        }'

    - name: Notify Teams on Failure
      if: failure()
      run: |
        curl -X POST ${{ secrets.TEAMS_WEBHOOK_URL }} \
        -H 'Content-Type: application/json' \
        -d '{
          "text": "🚨 Deployment Failed",
          "sections": [{
            "activityTitle": "Deployment Failure",
            "activitySubtitle": "'"${{ github.repository }}"'",
            "facts": [
              {"name": "Environment", "value": "Production"},
              {"name": "Branch", "value": "'"${{ github.ref_name }}"'"},
              {"name": "Commit", "value": "'"${{ github.sha }}"'"},
              {"name": "Status", "value": "Failed - Auto-rollback initiated"}
            ]
          }]
        }'